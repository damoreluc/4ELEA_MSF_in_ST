<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_MSF" Id="{22fb2750-2b9f-0d02-3ddd-c02de7144220}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MSF
VAR_INPUT
	input 	: stInput;
END_VAR
VAR_IN_OUT
	output	: stOutput; 	
END_VAR
VAR
	// abilitazione dell’automatismo
	enable : BOOL;

	// condizioni di transizione
	tr_S0_S1 : BOOL;
	tr_S1_S2 : BOOL;
	tr_S2_S3 : BOOL;
	tr_S3_S1 : BOOL;
	tr_S3_S0 : BOOL;
	tr_SE_SA : BOOL;
	tr_SA_S0 : BOOL;
	
	// variabile di stato
	stato : eStati := eStati.S0;

	// timers
	T31   : TON();
	TA0   : TON();

	// triggers per segnalazione nastro libero
	pckin : R_TRIG();
	pckout: R_TRIG();
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//    1. aggiornamento delle condizioni di abilitazione (input.stop, allarmi, etc)
	enable := input.stop AND input.emg;

//    2. aggiornamento di timers, contatori, triggers sui fronti
	T31(IN := (stato = eStati.S3 AND enable), PT := T#10S );
	TA0(IN := (stato = eStati.SA), PT := T#10S );
	pckin(clk:= input.fc1);
	pckout(clk:= input.fc2);
	
//    3. valutazione della condizione di arresto nominale
	IF NOT input.stop AND input.emg THEN
		stato := eStati.S0;
	END_IF
	
//    4. valutazione della condizione di arresto di emergenza
	IF (stato <> eStati.S0 AND NOT input.emg) THEN
		stato := eStati.SE;
	END_IF
	
//    5. aggiornamento delle condizioni di transizione di stato
	tr_S0_S1 := enable AND input.start;
	tr_S1_S2 := enable AND input.fc1 AND NOT input.fc2;
	tr_S2_S3 := enable AND input.fc2;
	tr_S3_S1 := enable AND input.fc1 AND NOT input.fc2 AND NOT T31.Q;
	tr_S3_S0 := enable AND T31.Q;
	tr_SE_SA := enable AND input.ack;
	tr_SA_S0 := enable AND TA0.Q;

//    6. switch-case della MSF
	CASE stato OF
	eStati.S0:
	    // comando uscite
		output.H1 := FALSE;
		output.HEmg := FALSE;
		output.HEmglamp := FALSE;
		//output.Libero := FALSE;
		output.M := FALSE;
		output.Idle := T#0S;
		
		// transizione di stato
		IF tr_S0_S1 THEN
			stato := eStati.S1;
		END_IF
	eStati.S1:
	    // comando uscite
		output.H1 := TRUE;
		output.HEmg := FALSE;
		output.HEmglamp := FALSE;
		//output.Libero := FALSE;
		output.M := FALSE;
		output.Idle := T#0S;
				
		// transizione di stato
		IF tr_S1_S2 THEN
			stato := eStati.S2;
		END_IF
	eStati.S2:
	    // comando uscite
		output.H1 := TRUE;
		output.HEmg := FALSE;
		output.HEmglamp := FALSE;
		//output.Libero := FALSE;
		output.M := TRUE;
		output.Idle := T#0S;
				
		// transizione di stato
		IF tr_S2_S3 THEN
			stato := eStati.S3;
		END_IF	
	eStati.S3:
	    // comando uscite
		output.H1 := TRUE;
		output.HEmg := FALSE;
		output.HEmglamp := FALSE;
		//output.Libero := FALSE;
		output.M := TRUE;
		output.Idle := T31.ET;
				
		// transizione di stato
		IF tr_S3_S1 THEN
			stato := eStati.S1;
		ELSIF tr_S3_S0 THEN
			stato := eStati.S0;
		END_IF
		
	eStati.SE:
	    // comando uscite
		output.H1 := TRUE;
		output.HEmg := TRUE;
		output.HEmglamp := FALSE;
		//output.Libero := FALSE;
		output.M := FALSE;
		output.Idle := T#0S;
				
		// transizione di stato
		IF tr_SE_SA THEN
			stato := eStati.SA;
		END_IF
		
	eStati.SA:
	    // comando uscite
		output.H1 := TRUE;
		output.HEmg := FALSE;
		output.HEmglamp := TRUE;
		output.Libero := FALSE;
		output.M := FALSE;
		output.Idle := T#0S;
				
		// transizione di stato
		IF tr_SA_S0 THEN
			stato := eStati.S0;
		END_IF
	ELSE
		stato := eStati.SE;	
	END_CASE


//    7. comando delle uscite
//	output.H1 := stato <> eStati.S0;
//	output.HEmg := (stato = eStati.SE);
//	output.HEmglamp := (stato = eStati.SA);
//	output.M := (stato = eStati.S2) OR (stato = eStati.S3);
	
	// nastro libero se (enable = true e  pckout.q) o (fc1 libero in S1);
	// nastro occupato se enable = false o fc1.rise o stato = S0
	IF (enable AND (pckout.q)) OR (stato = eStati.S1 AND NOT input.fc1) THEN
		output.libero := TRUE;
	ELSIF (NOT enable) OR pckin.Q OR stato = eStati.S0 THEN
		output.libero := FALSE;
	END_IF]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>